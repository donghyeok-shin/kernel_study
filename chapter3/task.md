## 3. 태스크 관리

### 3.1 프로세스와 쓰레드, 태스크

- 태스크 : 자원소유권의 단위

- 쓰레드 : 수행의 단위

- 프로세스 : 동작중인 프로그램

- 프로그램 : 디스크에 저장된 실행 가능한 형태의 파일.

  

### 3.2 사용자 입장에서 프로세스 구조

사용자 프로세스가 수행되기 위해서는 커널로 부터 가상 주소 공간을 할당받아야 함. 32bit CPU의 경우 os는 각 프로세스에게 4GB(2^32) 크기의 가상 공간을 할당함.

프로세스는 크게 4가지 영역으로 구분되며, 각 영역을 세그먼트(segment) 또는 가상 메모리 객체(vm_area_struct)라고 부름.

- 텍스트(text) : 명령, 함수 등으로 구성되며, 프로세스 주소 공간의 가장 하위 영역. 실행되는 기계어 명령어, 어셈블리 코드가 저장되는 영역.

- 데이터(data) : data영역은 bss, data 영역으로 나눠지며, 전역 변수 등을 저장하는 공간. bss에는 초기화되지 않은 변수, data에는 초기화된 변수가 저장됨.

- 스택(stack) : 함수의 지역 변수를 담으며, 유저 영역과 커널 영역의 경계에 위치하며, 아래 방향으로 증가함.

- 힙(heap) : malloc/free 등 동적 할당의 영역이다. data의 위에 위치하며 heap은 위로 증가한다.

  ![image-20210712000951215](https://raw.githubusercontent.com/donghyeok-shin/image_server/main/img/image-20210712000951215.png)



### 3.3 프로세스와 쓰레드의 생성과 수행

fork()를 이용해 자식 프로세스를 생성할 수 있으며, fork() 함수는 부모에게는 자식 pid, 자식에게는 0, 실패하면 -1을 return함. 프로세스가 생성될 때 주소공간을 포함하여 프로세스를 위한 `모든 자원들이 새로 할당`됨.

clone()를 이용해 쓰레드를 생성할 수 있으며, 프로세스 생성과 달리 쓰레드는 자식과 부모 쓰레드가 같은 주소공간을 공유함(위와 달리 새로 할당하지 않음).

execl()은 기존 프로세스의 주소 공간을 모두 없애며, 요청된 바이너리로 새로운 주소 공간을 생성함. fork와 vfork의 차이는 fork는 부모 프로세스의 주소공간을 복사하지만, vfork는 생성하지 않고 우선 같은 주소를 가리키며 execl을 사용해야 새롭게 공간을 할당받음.

vfork가 생긴 이유는 어차피 execl을 사용할 것이라면, excel은 요청된 바이너리의 주소공가능을 새롭게 생성하기 때문에 fork처럼 부모 프로세스의 주소공간을 복사하는 것이 무의미함. 이러한 불필요한 작업을 줄이기 위해 vfork가 사용됨.



### 3.4 리눅스의 태스크 모델

리눅스에서 프로세스 또는 쓰레드를 생성할 때 새로운 task_struct 자료구조를 생성함. 커널 내부에서는 프로세스, 쓰레드 둘 다 `태스크`라는 객체로 관리됨.

시스템에 존재하는 프로세스는 유일하게 구분이 가능해야함. 이 값은 task_struct에 pid 필드에 있음. POSIX 표준에 의하면 `한 프로세스 내의 쓰레드는 동일한 pid를 공유`라고 명시됨. 리눅스는 이를 위해 tgid(thread group id)를 도입함.

유저가 프로세스를 생성한다면, 생성된 프로세스의 tgid값과 pid가 동일함. 따라서 tgid, pid 모두 유일함.

유저가 쓰레드를 생성한다면, 부모 쓰레드와 자식 쓰레드가 tgid가 같음. tgid를 공유함.

==3.4 코드 정리 아직 안함 필요함==



### 3.5 태스크 문맥

- 태스크의 pid, tgid 등 식별자
- 프로세스나 쓰레드를 관리하기 위한 task_struct
- 파일 디스크립터
- 태스크 스케줄링을 위한 우선순위, cpu 사용량 등
- 태스크 가족관계, 시그널, 사용하고 있는 자원 등
- etc..

태스크와 관련된 이러한 모든 정보들을 '문맥'이라고 부르며, 크게 세가지로 분류됨.

- 시스템 문맥 : 태스크의 정보를 유지하기 위해 커널이 할당한 자료구조
  -  task_struct
  - 파일 디스크립터(fd)
  - 파일 테이블
  - 세그먼트 테이블
  - 페이지 테이블
  - etc..
- 메모리 문맥 : 텍스트, 데이터, 스택, 힙, 스왑 공간 등
- 하드웨어 문맥 : 문맥 교환(context switch)할 때 테스크의 현재 실행 위치에 대한 정보를 유지, 쓰레드 구조 또는 하드웨어 레지스터 문맥이라고 부름. 이 문맥은 실행 중이던 태스크가 대기 상태나 준비 상태로 전이할 때 어디까지 실행했는지 기억하는 공간.



### 3.6 상태 전이(State Transition)와 실행 수준 변화

태스크가 디스크 I/O, Lock 등 CPU 이외의 자원을 요청할 때 커널이 해당 자원을 당장 제공할 수 없다면, 요청한 태스크를 잠시 `대기`상태로 만든 후 다른 태스크를 수행시킴. 이후 요청 받은 자원을 제공할 수 있을 때 태스크를 다시 깨워 수행시킴으로써 높은 시스템 활용률이 가능함. 이러한 특징을 `상태 전이`라고 함.

![img](https://raw.githubusercontent.com/donghyeok-shin/image_server/main/img/1537D8494FE7B3DC29)

- TASK_RUNNING : 태스크가 생성됐을 때 TASK_RUNNING(ready) 상태가 됨. 커널이 스케줄링해서 CPU를 배정받아 명령어들을 처리할 수 있게 되며 상태는 TASK_RUNNING(running)가 됨. n개의 CPU라면, 최대 n개의 태스크가 TASK_RUNNING(running)상태일 수 있음.

  TASK_RUNNING(running) 상태에서 할당된 CPU시간을 다 소모하거나 높은 우선순위 때문에 스케줄링 되는 경우 TASK_RUNNING(ready)상태로 전이됨.

  running 상태의 태스크는 태스크 실행 권한에 따라 `user level running`, `kernel level running`으로 구분됨.

  - user level : 프로그램 제작자가 만든 응용 프로그램이나 라이브러리 코드를 수행하는 상태
  - kernel level : CPU에서 커널 레벨의 코드를 수행하는 상태이며, user level에서 시스템 호출을 하거나 인터럽트가 발생할 때 kernel level로 전이됨. 시스템 호출, 인터럽트 처리가 완료되면 다시 user level로 전이됨. 이때 커널은 태스크가 시그널을 받았는지 확인하고, 필요하다면 받았으면 시그널 처리 핸들러를 호출함. 그리고 다시 스케줄링 해야 할 필요가 있다면 스케줄러를 호출함. 마지막으로 커널 내 delay된 루틴들이 존재하면 이들을 수행함.

- TASK_DEAD : 태스크가 할 일을 끝나면(태스크가 exit()를 호출하거나, kill이 되거나) TASK_DEAD(EXIT_ZOMBIE) 상태가 됨. ZOMBIE상태는 죽어있는 상태로 대부분의 자원을 커널에 반납하며, 자신이 종료된 이유(error 번호), 사용 자원의 통계 정보 등을 부모 태스크에게 알려주기 위해 유지되는 상태.

  부모 태스크가 wait() 등의 함수를 호출하면, ZOMBIE 태스크는 유지하고 있던 자원을 모두 반납하고 TASK_DEAD(EXIT_DEAD) 상태로 바뀜. 부모가 wait() 등의 함수를 호출하기 전에 먼저 종료된다해도 고아 태스크가 되지는 않음. 커널은 고아 태스크가 되는 것을 막기 위해 고아 태스크의 부모 태스크를 init 태스크로 변경하며, init 태스크가 wait() 등의 함수를 호출하여 자식을 소멸시킴.

- TASK_STOPED : SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU 등의 시그널을 받은 태스크는 TASK_STOPED 상태로 전이됨. SIGCONT 시그널을 받으면 TASK_RUNNING(ready) 상태로 전이됨.

- TASK_TRACED : 디버거의 ptrace() 호출에 의해 디버깅 되는 경우 태스크는 시그널을 받으면 TASK_TRACED상태로 전이됨.

- TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE, TASK_KILLABLE(`대기 상태`) : TASK_RUNNING(running) 상태에서 기다려야할 필요(디스크 같은 주변 장치에 요청을 보내고 요청이 완료되기까지 기다리거나, 사용 중인 시스템 자원 대기 등의 상황에)가 있으면 이러한 대기 상태로 전이됨. TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE 둘다 특정 이벤트를 기다리는 면에서는 유사하지만, TASK_UNINTERRUPTIBLE은 시그널에 반응하지 않음(kill -9 PID에도 반응 안함). 그래서 TASK_KILLABLE이라는 중요한 시그널에 반응하는 상태가 도입됨.

  `대기 상태` 태스크가 기다리는 사건에 따라 특정 큐에 매달려 대기함. 이 태스크가 대기 상태가 됐기 때문에 효율을 위해 스케줄러는 TASK_RUNNING(ready) 상태의 태스크를 TASK_RUNNING(running) 상태로 만듬.

  기다라는 event가 있어서 `대기 상태`에 있던 태스크는 event가 발생하면 다시 TASK_RUNNING(ready)상태가 됨.
